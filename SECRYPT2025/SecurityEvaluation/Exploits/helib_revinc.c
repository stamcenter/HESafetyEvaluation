#include <stdio.h>
#include <stdlib.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/***
 * The RevInc function in performs a bitwise operation on the input values a depending on k. 
 * m is initialized to 2^(kâˆ’1). This is done by left-shifting the value 1L (which is a long integer) by (k-1) bits.
 * The function essentially increments a in a "reversed" manner with respect to its binary representation, controlled by the parameter k. 
 * It toggles bits in a starting from the (k-1)-th bit down to the least significant bit, until a zero bit is encountered or j (initially k) becomes zero.
 * Vulnerability
 * The function does not check if k is a valid input (e.g., non-negative and within a reasonable range for the bit size of a).
 *  If k is too large or negative, the behavior is undefined.
 * If k is zero or negative, the left shift operation 1L << (k - 1) can result in undefined behavior or unintended results due 
 * to shifting by a negative number or by more bits than the size of the data type.
 * If k is larger than 64, it will lead to an Integer Overflow:  since we are trying to shift a bit beyond the 64-bit boundary.
 * **/
long RevInc(long a, long k) {
    long j = k;
    long m = 1L << (k - 1);
    long d = k-1;
    // long val = pow(2, (double)k);
    printf("value of m: %ld \n", m);
    // printf("value of val (2^(k-1)) %ld: \n", val);


    while (j && (m & a)) {
        a ^= m;
        m >>= 1;
        j--;
    }
    if (j)
        a ^= m;
    return a;
}


// static long* BRC_init(long k)
// {
//   NTL::Vec<long>* brc_mem = get_brc_mem();

//   long n = (1L << k);
//   brc_mem[k].SetLength(n);
//   long* rev = brc_mem[k].elts();
//   for (long i = 0, j = 0; i < n; i++, j = RevInc(j, k))
//     rev[i] = j;
//   return rev;
// }

// static void BasicBitReverseCopy(long* NTL_RESTRICT B,
//                                 const long* NTL_RESTRICT A,
//                                 long k)
// {
//   NTL::Vec<long>* brc_mem = get_brc_mem();

//   long n = 1L << k;
//   long* NTL_RESTRICT rev;

//   rev = brc_mem[k].elts();
//   if (!rev)
//     rev = BRC_init(k);

//   for (long i = 0; i < n; i++)
//     B[rev[i]] = A[i];
// }

/***
 * Setting b to 65 (or any value greater than 64) will result in the left shift operation 1L << (b - 1) 
 * causing overflow, since we are trying to shift a bit beyond the 64-bit boundary.
 */
int main(int argc, char *argv[]) {
    long a = 0;
    long b = 64;      
    long c;

    // long* rev;
	  // for (long i = 0, j = 0; i < n; i++, j = RevInc(j, k))
	  //   rev[i] = j;
	  c = RevInc(a, b);
    printf("long a: %ld\n", a);

    printf("this is the revInc %ld\n", c);
    return 0;
}

// -9223372036854775808
// -9223372036854775808
// -9223372036854775808
// -9223372036854775872